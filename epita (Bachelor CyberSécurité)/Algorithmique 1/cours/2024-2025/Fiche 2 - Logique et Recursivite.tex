\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\newcommand{\TitreMatiere}{Algorithmique 1}
\newcommand{\TitreSeance}{[PROF] Logique et Récursivité}
\newcommand{\SousTitreSeance}{Fiche 2}
\newcommand{\DateCours}{Octobre 2024}
\newcommand{\AnneeScolaire}{2024-2025}
\newcommand{\Organisation}{EPITA}
\newcommand{\NomAuteurA}{Fabrice BOISSIER}
\newcommand{\MailAuteurA}{fabrice.boissier@epita.fr}
\newcommand{\NomAuteurB}{ }
\newcommand{\MailAuteurB}{ }
\newcommand{\DocKeywords}{Algorithmique ; Algorithmes ; Logique ; Récursivité ; Récursif ; Récurrence}
\newcommand{\DocLangue}{fr} % "en", "fr", ...

\usepackage{MetalCourseBooklet}

% Babel ne traduit pas toujours bien les tableaux et autres
\renewcommand*\frenchfigurename{%
    {\scshape Figure}%
}
\renewcommand*\frenchtablename{%
    {\scshape Tableau}%
}

% Ne pas afficher le numéro de la légende sur tableaux et figures
\captionsetup{format=sanslabel}


\begin{document}

\EncadreTitre

\bigskip


%\begin{center}
%\begin{tabular}{p{5cm} p{11cm}}
%\textbf{Commandes étudiées :} & \texttt{sh}, \texttt{bash}, \texttt{man}, \texttt{ls}, \texttt{mkdir}, \texttt{touch}, \texttt{chmod}, \texttt{mv}, \texttt{rm}, \texttt{rmdir}, \texttt{cat}, \texttt{file}, \texttt{which}, \texttt{which}\\
%
%\textbf{Builtins étudiées :} & \texttt{pwd}, \texttt{cd}, \texttt{exit}, \texttt{logout}, \texttt{echo}, \texttt{umask}, \texttt{type}, \texttt{>}, \texttt{>{}>}, \texttt{<}, \texttt{<{}<}, \texttt{|}\\
%
%\textbf{Notions étudiées :} & Shell, Manuels, Fichiers, Répertoires, Droits, Redirections\\
%\end{tabular}
%\end{center}

\bigskip


Ce document a pour objectif de guider les enseignants pour le cours d'algorithmique.
Il est déconseillé de le fournir aux étudiants, car il vise surtout à vous permettre de guider la séance.
Vous n'êtes évidemment pas obligé de le suivre à la lettre (c'est même déconseillé, car cela va autant vous perturber vous que la classe : suivez votre chemin de pensée et/ou celui de la classe, et ensuite vérifiez que vous n'avez rien oublié).

\medskip

La deuxième partie vise à découvrir la notion de récursivité, et de façon cachée à se rendre compte des effets de l'ordre des conditions à base de \textit{if ... else}.
Il ne faut pas hésiter à insister sur les conséquences des cascades de \textit{if} imbriqués sur les cas absorbés dès le début/les cas non détectés par l'enchaînement sauvage de conditions.

Aucun ordinateur n'est nécessaire : vous pouvez les interdire pendant cette séance, néanmoins, n'hésitez pas à montrer ou à faire tester à l'un des étudiant l'algorithme de Ackermann avec les paramètres \textit{(1, 1)}, \textit{(2, 2)}, \textit{(3, 3)}, puis \textit{(4, 3)} en mesurant le temps passé (éventuellement avec la commande \textit{time}).
N'importe quelle implémentation sur OCaml ou Python suffit.
N'hésitez pas à leur demander de tester le cas \textit{(8, 8)} qui devrait faire déborder la pile d'appels.

\bigskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Logique}

\bigskip

\begin{itemize}
\item Explications de base : la \textit{logique} est un domaine des mathématiques avec de nombreux sous-domaines et applications (logique de premier ordre, ...)
\item (Instant Culture G : \textit{La logique est initialement issue de la Philosophie dans l'antiquité afin de permettre d'établir des assertions et des raisonnements logiques/qui ne soient pas contradictoires... et sa formalisation l'a amenée à devenir une partie des mathématiques. Néanmoins il existe encore un champs de recherche \og logique \fg{}, propre à la Philosophie, enseigné dans les universités ainsi que des publications sous forme de livres dans des librairies spécialisées})
\item La logique est utilisée en électronique numérique avec les portes logiques (\textit{logic gates} en anglais) et les bascules (\textit{flip-flops} en anglais)
\end{itemize}

\begin{itemize}
\item La logique s'appuie sur deux valeurs qui s'opposent : \TTBF{vrai} (1) et \TTBF{faux} (0)
\item Les \textit{formules logiques} permettent de vérifier des assertions avec des opérateurs
\item Opérateurs logiques et leurs tables de vérité : \textit{NOT} (opérateur unaire), \textit{AND}, \textit{OR} (opérateurs binaires)
\item Explication des \textit{tables de vérité} : elles présentent tous les états possibles
\end{itemize}

\bigskip

\begin{table}[ht!]
    \centering
    \hfill
    \begin{tabular}{|c|c|}
        \hline
        A & \TTBF{NOT} \tabularnewline
        \hline
        0 & 1 \tabularnewline
        \hline
        1 & 0 \tabularnewline
        \hline
    \end{tabular}
    \hfill
    \begin{tabular}{|c|c|c|}
        \hline
        A & B & \TTBF{AND} \\
        \hline
        0 & 0 & 0 \\
        \hline
        0 & 1 & 0 \\
        \hline
        1 & 0 & 0 \\
        \hline
        1 & 1 & 1 \\
        \hline
    \end{tabular}
    \hfill
    \begin{tabular}{|c|c|c|}
        \hline
        A & B & \TTBF{OR} \\
        \hline
        0 & 0 & 0 \\
        \hline
        0 & 1 & 1 \\
        \hline
        1 & 0 & 1 \\
        \hline
        1 & 1 & 1 \\
        \hline
    \end{tabular}
    \hfill\null
\end{table}

\bigskip

\begin{itemize}
\item Rappel que \textit{NOT}, \textit{AND}, \textit{OR} sont utilisés en algorithmique...
\item ...mais il existe d'autres opérateurs logiques utilisés en mathématiques...
\item ...ainsi qu'en électronique numérique, mais dans un format un peu spécial.
\item Montrer les opérateurs \textit{NAND}, \textit{NOR}, et surtout \textit{XOR}
\end{itemize}

\bigskip

\begin{table}[ht!]
    \centering
    \hfill
    \begin{tabular}{|c|c|c|}
        \hline
        A & B & \TTBF{NAND} \\
        \hline
        0 & 0 & 1 \\
        \hline
        0 & 1 & 1 \\
        \hline
        1 & 0 & 1 \\
        \hline
        1 & 1 & 0 \\
        \hline
    \end{tabular}
    \hfill
    \begin{tabular}{|c|c|c|}
        \hline
        A & B & \TTBF{NOR} \\
        \hline
        0 & 0 & 1 \\
        \hline
        0 & 1 & 0 \\
        \hline
        1 & 0 & 0 \\
        \hline
        1 & 1 & 0 \\
        \hline
    \end{tabular}
    \hfill
    \begin{tabular}{|c|c|c|}
        \hline
        A & B & \TTBF{XOR} \\
        \hline
        0 & 0 & 0 \\
        \hline
        0 & 1 & 1 \\
        \hline
        1 & 0 & 1 \\
        \hline
        1 & 1 & 0 \\
        \hline
    \end{tabular}
    \hfill\null
\end{table}

\bigskip

\begin{itemize}
\item Montrez les symboles logiques :
  \begin{itemize}[label=$\bullet$]
  \item NON / Négation : $ \neg $  \hspace*{2cm}  autre notation : $ \overline{A} $
  \item ET / Conjonction : $ \wedge $  \hspace*{2cm}  autre notation : $ A \cdot B $ (agit comme un $ \times $ entre les états)
  \item OU / Disjonction : $ \vee $  \hspace*{2cm}  autre notation : $ A + B $ (agit comme un $ + $ entre les états)
  \item Chaque notation vise un public/domaine précis :
    \begin{itemize}[label=]
    \item Mathématiques/logique ($ \neg \wedge \vee $)
    \item \'Electronique numérique ($ \overline{A} \cdot B $)
    \item Algorithmique (\TTBF{AND OR} \hspace*{0.1cm} / \hspace*{0.1cm} \TTBF{\&\& ||})
    \end{itemize}
  \end{itemize}
\item Indiquez que distribuer un \textit{NOT} sur un \textit{AND}/\textit{OR} inverse l'opérateur (théorème de De Morgan)
  \begin{itemize}[label=$\bullet$]
  \item $ \neg ( A \wedge B ) \; = \; ( \neg A ) \vee ( \neg B ) $  \hspace*{2cm} (autre notation : $ \overline{\text{A} \cdot \text{B}} \; \; = \; \; \overline{\text{A}} + \overline{\text{B}} $ )
  \item $ \neg ( A \vee B )   \; = \; ( \neg A ) \wedge ( \neg B ) $  \hspace*{2cm}  (autre notation : $ \overline{\text{A} + \text{B}} \; \; = \; \; \overline{\text{A}} \cdot \overline{\text{B}} $ )
  \end{itemize}
\item Effectuez un exemple avec une table de vérité pour le prouver aux étudiants
\item Expliquez les \textit{conjonctions de cas} et les \textit{disjonctions de cas}*
  \begin{itemize}[label=$\bullet$]
  \item Conjonction de cas : $ ( A \vee B \vee C) \wedge ( \neg A \vee B ) \wedge ... $
  \item Disjonction de cas : $ ( A \wedge B \wedge C) \vee ( \neg A \wedge B ) \vee ... $
  \end{itemize}
\item Demandez à la classe lequel est le plus optimal et dans quel cas
  \begin{itemize}[label=$\bullet$]
  \item Conjonction de cas = une condition est fausse $ \Rightarrow $ tout est faux
  \item Disjonction de cas = une condition est vraie $ \Rightarrow $ tout est vrai
  \end{itemize}
\end{itemize}

\bigskip

%Dans les programmes que vous développez, vous utiliserez régulièrement des conditions pour vérifier des assertions.
%Cependant, il existe un autre usage que la vérification de condition pour les opérateurs booléens précédemment présentés.
%Lorsque l'on représente des valeurs numériques dans un ordinateur avec des bits, on peut appliquer les opérateurs booléens dessus et modifier la valeur représentée.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Exercices de logique}

\subsubsection{Exercices sur les conditions}

\question{Transformez les conditions suivantes en distribuant la négation :}

\medskip

\TTBF{int A, B, C, D;}

\begin{enumerate}[label=\alph*]
\item \TTBF{ if (! (A > 2) ) }
\item \TTBF{ if (! \textcolor{darkorange}{(}(A >= 2) AND (B < 3)\textcolor{darkorange}{)} ) }
\item \TTBF{ if (! \textcolor{gray}{(} \textcolor{red}{(}(A != B) OR (B == C)\textcolor{red}{)} AND \textcolor{blue}{(}! \textcolor{darkorange}{(}(A == C) OR (B != D)\textcolor{darkorange}{)}\textcolor{blue}{)} \textcolor{gray}{)} ) }
\end{enumerate}

\medskip

%\question{Écrivez une condition (juste le \textit{if}) prenant 2 éléments et testant l'effet du \textit{XOR} sur eux (exemple : recoder \textit{NAND} sous forme de condition implique simplement de faire la négation du \textit{AND} de 2 éléments)}
\question{Écrivez une condition à base de \textit{AND}, \textit{OR}, \textit{NOT} reproduisant l'effet du \textit{XOR} sur deux valeurs A et B}


\subsubsection{Algorithmes}

\question{Écrivez une fonction prenant 3 entiers différents en paramètre, et indiquant lequel est le plus petit/grand. $ \; \; $ \textit{min(a, b, c) $ \; \; $ max(a, b, c)} }

\question{Écrivez une fonction prenant 3 entiers différents en paramètre, et renvoyant l'élément intermédiaire. $ \; \; $ \textit{middle(a, b, c)} }

\question{Améliorez ces fonctions pour qu'elles prennent en chargent les cas où des valeurs égalent sont données en paramètres : (3, 2, 2), (3, 4, 3), (7, 7, 7), ...}

\question{Écrivez une fonction effectuant la somme des carrés des 2 plus grands/petits nombres parmi 3. \textit{SumSquare(a, b, c)} }


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Récursivité}

\bigskip

\begin{itemize}
\item Expliquer que la récursivité est simplement une fonction qui se rappelle elle-même
\item Rappeler que certains l'ont vu en mathématiques avec le raisonnement par récurrence
\item Demander quel était le principe du raisonnement par récurrence à la classe :
  \begin{itemize}[label=$\bullet$]
  \item Très souvent le cas 0, ou le cas minimal/maximal
  \item Le cas général entre l'itération N et l'itération N+1
  \end{itemize}
\item \'Ecrire une fonction récursive se fait de la même manière :
  \begin{itemize}[label=$\bullet$]
  \item Le(s) cas d'arrêt d'abord
  \item Le cas général récursif en dernier
  \end{itemize}
\item \textit{WARNING : Bien rappeler et expliquer qu'il est très important de mettre le cas d'arrêt d'abord !}
\item Montrez ce qu'il se passerait si on mettait le cas d'arrêt \textit{après} l'appel récursif général
\end{itemize}

\bigskip


\subsection{Exercices récursifs}

Maintenant que vous avez écrit quelques algorithmes simples avec des boucles, nous allons passer à leurs versions récursives.

\bigskip

\question{Commencez par exécuter l'algorithme de la somme des N premiers entiers en remplissant le tableau avec l'évolution des paramètres donnés dans un premier temps, puis des résultats. Vous effectuerez cette exécution avec $ 5 $ comme paramètre.}

\bigskip

\begin{table}[!ht]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
%    \begin{verbatim}
% %*   *)
\begin{lstlisting}[style=algorithmique]
algorithme fonction SommeRec : entier
  parametres locaux
    entier    n

debut
si (n == 1) alors
  retourne (1)
sinon
  retourne (n + SommeRec(n - 1))
fin si
fin algorithme fonction SommeRec \end{lstlisting}
%    \end{verbatim}
    % \caption{Algorithme de la somme des N premiers entiers}
    % \label{algo-somme-n-premiers-entiers-recursif}
  \end{minipage}
  \hfillx
  \begin{minipage}{0.19\textwidth}
    \centering
    \begin{tabular}{|C{1.1cm}|C{1.1cm}|}
        \hline
        appel &  n  \\
        \hline
              &     \\
        0     &     \\
              &     \\
        \hline
              &     \\
        1     &     \\
              &     \\
        \hline
              &     \\
        2     &     \\
              &     \\
        \hline
              &     \\
        3     &     \\
              &     \\
        \hline
              &     \\
        4     &     \\
              &     \\
        \hline
              &     \\
        5     &     \\
              &     \\
        \hline
              &     \\
        6     &     \\
              &     \\
        \hline
    \end{tabular}
    % \caption{Tableau d'appels}
    % \label{table-somme-n-premiers-entiers-appels}
  \end{minipage}
  \hfillx
  \begin{minipage}{0.28\textwidth}
    \centering
    \begin{tabular}{|C{1.1cm}|C{1.1cm}|C{1.1cm}|}
        \hline
        appel & retour & total \\
        \hline
              &        & \\
        6     &        & \\
              &        & \\
        \hline
              &        & \\
        5     &        & \\
              &        & \\
        \hline
              &        & \\
        4     &        & \\
              &        & \\
        \hline
              &        & \\
        3     &        & \\
              &        & \\
        \hline
              &        & \\
        2     &        & \\
              &        & \\
        \hline
              &        & \\
        1     &        & \\
              &        & \\
        \hline
              &        & \\
        0     &        & \\
              &        & \\
        \hline
    \end{tabular}
    % \caption{Tableau de retours}
    % \label{table-somme-n-premiers-entiers-retours}
  \end{minipage}
  \caption{Somme des N premiers entiers (récursif)}
  \label{somme-n-premiers-entiers-recursif}
\end{table}


%\bigskip
\clearpage


\question{Écrivez maintenant l'algorithme de la factorielle, mais de façon récursive. N'oubliez pas : on écrit d'abord la ou les conditions d'arrêt, et ensuite seulement on effectue l'opération avec l'appel récursif.}

\begin{equation*}
  \begin{aligned}
& n! = 1 \times 2 \times 3 \times \ldots \times n
  \end{aligned}
\end{equation*}

\bigskip

\question{Écrivez l'algorithme récursif calculant la somme des N premiers entiers.}

\begin{equation*}
  \begin{aligned}
& \sum^{n}_{i = 1} i = 1 + 2 + 3 + \ldots + n
  \end{aligned}
\end{equation*}

\bigskip

\question{Écrivez l'algorithme récursif calculant la multiplication de deux entiers positifs, en n'utilisant que des additions et des soustractions.}

\question{Améliorez l'algorithme de la multiplication pour qu'elle gère maintenant les nombres négatifs. Vous pouvez pour cela vous aider d'une fonction chapeau, c'est-à-dire une fonction qui prend les deux paramètres attendus (les deux nombres à multiplier) et fait différents tests avant d'appeler une autre fonction qui elle sera récursive.}

\bigskip

\question{Écrivez l'algorithme récursif calculant le Nième terme d'une suite géométrique. Vous devriez avoir en paramètres : le terme $ u_{0} $ désignant le premier terme de la suite, la raison $ q $, et le numéro $ n $ du terme recherché.}

\begin{equation*}
  \begin{aligned}
& u_{n} = u_{0} \times q^{n}
  \end{aligned}
\end{equation*}

\bigskip

\question{Écrivez une fonction récursive calculant le $ n^{\text{ème}} $ terme de la suite de Fibonacci.}

\begin{equation*}
  \begin{aligned}
& fibo(0) = 0\\
& fibo(1) = 1 \; \; \; \; \; \; \text{(pour simplifier, on considérera que : } fibo(0) = fibo(1) = 1 \text{)}\\
& fibo(n) = fibo(n - 1) + fibo(n - 2)
  \end{aligned}
\end{equation*}

\question{Écrivez maintenant la version itérative de la suite de Fibonacci. [Astuce : on dispose de deux cas à valeurs fixes, et à chaque étape on doit se rappeler du résultat précédent.] }

\bigskip

\question{Écrivez une fonction récursive calculant le $ n^{\text{ème}} $ terme de la suite d'Ackermann.}

\begin{equation*}
  \begin{aligned}
& A(0, n) = n + 1                 &  [n >= 0] & \\
& A(m, 0) = A(m - 1, 1)           &  [m > 0]  & \\
& A(m, n) = A(m - 1, A(m, n - 1)) &  [m > 0 \; \& \; n > 0] &
  \end{aligned}
\end{equation*}

\bigskip

\question{Écrivez l'algorithme récursif calculant le nombre de combinaisons de $ p $ dans $ n $ ($ C^{p}_{n} $ ou CPN), c'est-à-dire le nombre de parties à $ p $ éléments dans un ensemble $ E $ contenant $ n $ éléments.}

\bigskip

Par exemple : pour $ p = 2 $, on recherche tous les \textbf{couples} possibles de différents éléments.
Pour $ p = 3 $, on recherche tous les \textbf{triplets} possibles de différents éléments.
En indiquant $ n = 3 $, on vise un ensemble composé de trois éléments distincts (par exemple : $ E = \{ 1, 2, 3 \} $, ou $ E = \{ A, B, C \} $, ou $ E = \{ \spadesuit, \heartsuit, \clubsuit \} $, il s'agit juste de trois éléments distincts).

%\bigskip
\newpage

Ainsi, pour $ p = 2 $ et $ n = 3 $, on recherche tous les couples possibles de trois éléments :

\begin{table}[!ht]
  \centering
  \begin{tabular}{l l}
(A,B) & (A,C) \\
      & (B,C)
  \end{tabular}
\end{table}

\hspace*{3cm} $\Rightarrow$ $ C^{2}_{3} = 3 $ \hspace*{1cm} (3 couples possibles)

\bigskip

Pour $ p = 2 $ et $ n = 4 $, on recherche tous les couples possibles de quatre éléments :

\begin{table}[!ht]
  \centering
  \begin{tabular}{l l l}
(A,B) & (A,C) & (A,D) \\
      & (B,C) & (B,D) \\
      &       & (C,D)
  \end{tabular}
\end{table}

\hspace*{3cm} $\Rightarrow$ $ C^{2}_{4} = 6 $ \hspace*{1cm} (6 couples possibles)

\bigskip

Pour $ p = 3 $ et $ n = 3 $, on recherche tous les triplets possibles de trois éléments :

\begin{table}[!ht]
  \centering
  \begin{tabular}{l}
(A,B,C) \\
  \end{tabular}
\end{table}

\hspace*{3cm} $\Rightarrow$ $ C^{3}_{3} = 1 $ \hspace*{1cm} (1 triplet possible)

\bigskip

Pour $ p = 3 $ et $ n = 4 $, on recherche tous les triplets possibles de quatre éléments :

\begin{table}[!ht]
  \centering
  \begin{tabular}{l l l}
(A,B,C) & (A,B,D) & (A,C,D) \\
        &         & (B,C,D) \\
  \end{tabular}
\end{table}

\hspace*{3cm} $\Rightarrow$ $ C^{3}_{4} = 4 $ \hspace*{1cm} (4 triplets possibles)

\bigskip

Voici les axiomes pour votre implémentation :

\begin{table}[!ht]
  \centering
  \begin{tabular}{l l}
$ C(0,n) = 1 $                             & \\
$ C(n,n) = 1 $                             & $ [n \neq 0] $ \\
$ C(p,n) = C(p, n - 1) + C(p - 1, n - 1) $ & $ [n \neq p] $ \\
  \end{tabular}
\end{table}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Exercices variés (récursif \& itératif)}

\bigskip

Les exercices dans cette section doivent plutôt être réalisés en itératif.
Il est précisé lesquels peuvent aisément être réalisés en récursif.
Il est interdit d'utiliser les tableaux ou pointeurs pour réaliser ces exercices.

\bigskip

%\question{Écrivez une fonction prenant 3 entiers en paramètre, et indiquant lequel est le plus petit/grand. \textit{min(a, b, c) max(a, b, c)} }

%\bigskip

\question{Écrivez une fonction transformant un format horaire en un format uniquement composé de secondes. Cette fonction prendra 3 entiers en paramètre (les heures, les minutes, et les secondes) et les convertira en secondes. Par exemple, 1h 23m 45s deviendra 5025 secondes. \textit{ConversionHoraire1(hh, mm, ss)} }

\bigskip

\question{Écrivez une autre fonction de conversion horaire qui prend cette fois un unique entier qui respecte un format précis (hhmmss) pour le convertir en secondes. Par exemple le paramètre 153042 signifie 15h 30m 42s qu'il faut convertir en secondes. \textit{ConversionHoraire2(hhmmss)} }

\bigskip

\question{Écrivez une fonction qui transforme un nombre en son miroir. Cette fonction prend un entier en paramètre, et construit un autre entier qui est son miroir. Par exemple, pour 12034, son miroir sera 43021. Autre exemple : 2000 aura comme miroir 0002, c'est-à-dire 2. Attention aux nombres composés d'un nombre pair/impair de chiffres. Commencez par réaliser une fonction itérative. \textit{MiroirIter(n)} }

\bigskip

\question{Écrivez maintenant la version récursive du nombre miroir. Pour cette première version récursive, vous appelerez une fonction \textit{écrire(x)} ou \textit{print(x)} qui affiche un caractère ou un chiffre à la fois. \textit{MiroirRec1(n)} }

\bigskip

\question{Écrivez maintenant la version récursive du nombre miroir. Pour cette deuxième version récursive, vous devrez renvoyer le nombre miroir et non pas juste l'afficher. \textit{MiroirRec2(n)}}

Astuce : vous pouvez utiliser un \textit{accumulateur} comme deuxième paramètre, donc, écrire une fonction chapeau qui prendra un seul paramètre et préparera l'appel à la fonction récursive.

\bigskip

\question{Écrivez une fonction récursive qui affiche les éléments successifs de la conjecture de Syracuse, mais qui renvoie également le nombre d'éléments produits avant d'atteindre $ 1 $. Utilisez les fonctions \textit{écrire(x)} ou \textit{print(x)} et une fonction chapeau si nécessaire. \textit{Syracuse(n)} }

Voici les axiomes pour votre implémentation :

\begin{table}[!ht]
  \centering
  \begin{tabular}{l l}
$ Syracuse(0) = 1 $       & \\
$ Syracuse(1) = 1 $       & \\
$ Syracuse(n) = n / 2 $   & si $ n $ est paire \\
$ Syracuse(n) = 3n + 1 $  & si $ n $ est impaire \\
  \end{tabular}
\end{table}

\question{Écrivez une fonction détectant si un nombre est un palindrome. La fonction renvoie \textit{vrai} si c'est un palindrome, sinon elle renvoie \textit{faux}. Un palindrome est simplement un mot ou un nombre composé des mêmes caractères ou chiffres sur sa première moitié par rapport à sa deuxième moitié. Par exemple, 27972 est un palindrome. 1331 est également un palindrome, mais 1664 n'en est pas un. Faites d'abord une version itérative, puis faites une version récursive. \textit{PalindromeIter(n)} \textit{PalindromeRec(n)} }


%\bigskip

\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Récursivité terminale}

\bigskip

\begin{itemize}
\item Effectuez à la main au tableau la pile d'appels de \TTBF{Ackermann(5, 5)})... enfin quelques appels
\item Expliquez le principe de la \textit{pile d'appels} (\textit{call stack} en anglais) et que celle-ci est limitée dans les ordinateurs
  \begin{itemize}[label=$\bullet$]
  \item Demandez à la classe pourquoi la pile d'appels est limitée
  \item[$\Rightarrow$] Parce que les ordinateurs ont une mémoire limitée
  \item[$\Rightarrow$] Parce que la mémoire contient d'autres données et informations, et que la pile est limitée pour ne jamais pouvoir écrire ailleurs
  \end{itemize}
\item Expliquer ce que contient la pile d'appel : les paramètres donnés à une fonction, la ligne de code où l'on en était, la valeur retournée par la fonction, ...
\item Si la pile d'appels est trop remplie, à cause d'un excès d'appels de fonctions, alors cela déclenche un \textit{dépassement de pile} (en anglais \textit{stack overflow})
\end{itemize}

\medskip

\begin{itemize}
\item On peut réduire l'usage de la pile d'appels lorsque l'on effectue de la récursivité en utilisant une technique particulière : la \textit{récursivité terminale}
\item Montrez que Fibonacci en récursif classique se bloque sur une multiplication entre une valeur et un appel récursif
\item Expliquer que l'ordinateur doit donc attendre le retour de la fonction \textit{avant} de pouvoir faire sa multiplication
\item Entre chaque retour de fonction, il y a donc des opérations effectuées...
\item L'écriture de fonctions récursives terminales va éviter cela, et permettre de ne faire que renvoyer des valeurs en cascade
\item Plus précisément, on va construire la réponse finale au fur et à mesure, et dans l'appel le plus profond on aura le résultat final
\end{itemize}

%\medskip

\begin{table}[!ht]
  \centering
  \begin{minipage}{0.475\textwidth}
    \centering
%    \begin{verbatim}
% %*   *)
\begin{lstlisting}[style=algorithmique]
algorithme fonction FactR : entier
  parametres locaux
    entier    n

debut
si (n == 0) OU (n == 1) alors
  retourne (1)
sinon
  retourne (n * FactR(n - 1))
fin si
fin algorithme fonction FactR \end{lstlisting}
%    \end{verbatim}
    % \caption{Algorithme de la somme des N premiers entiers}
    % \label{algo-somme-n-premiers-entiers-recursif}
  \end{minipage}
  \hfillx
  \begin{minipage}{0.48\textwidth}
    \centering
%    \begin{verbatim}
% %*   *)
\begin{lstlisting}[style=algorithmique]
algorithme fonction FactRT : entier
  parametres locaux
    entier    n, acc

debut
si (n == 0) OU (n == 1) alors
  retourne (acc)
sinon
  retourne (FactRT(n - 1, n * acc))
fin si
fin algorithme fonction FactRT \end{lstlisting}
  \end{minipage}
\end{table}

\vspace*{-1cm}

\begin{itemize}
\item Explicitez le rôle de l'\textit{accumulateur} et le fait qu'il est renvoyé
\item Les conditons vont pouvoir capter plus de cas et renvoyer l'accumulateur plus tôt (pas besoin d'additionner $ 0 $ ou de multiplier par $ 1 $ un résultat avant de le renvoyer)
\item Rappelez que lorsque les consignes d'exercices, d'examens, ou d'API du monde réel, donnent un prototype précis de fonction à respecter : il faut le respecter
\item Demander à la classe comment ajouter un accumulateur tout en respectant le prototype strict qui n'en inclut pas
  \begin{itemize}
  \item[$\Rightarrow$] avec une fonction chapeau qui va préparer l'accumulateur
  \end{itemize}
\item Explicitez le fait que la valeur initiale de l'accumulateur va dépendre de la logique employée dans l'algorithme récursif
\end{itemize}



\begin{table}[!ht]
  \centering
  \begin{minipage}{0.478\textwidth}
    \centering
%    \begin{verbatim}
% %*   *)
\begin{lstlisting}[style=algorithmique]
algorithme fonction FChapo : entier
  parametres locaux
    entier    n

debut
si (n == 0) OU (n == 1) alors
  retourne (1)
sinon
  retourne (FactRT(n, 1))
fin si
fin algorithme fonction FChapo \end{lstlisting}
%    \end{verbatim}
    % \caption{Algorithme de la somme des N premiers entiers}
    % \label{algo-somme-n-premiers-entiers-recursif}
  \end{minipage}
  \hfillx
  \begin{minipage}{0.48\textwidth}
    \centering
%    \begin{verbatim}
% %*   *)
\begin{lstlisting}[style=algorithmique]
algorithme fonction FactRT : entier
  parametres locaux
    entier    n, acc

debut
si (n == 1) alors
  retourne (acc)
sinon
  retourne (FactRT(n - 1, n * acc))
fin si
fin algorithme fonction FactRT \end{lstlisting}
  \end{minipage}
\end{table}

\begin{itemize}
\item Expliquez qu'un algorithme récursif terminal se transforme facilement en algorithme itératif
  \begin{itemize}[label=$\bullet$]
  \item L'accumulateur devenant une variable évoluant au fur et à mesure des tours de boucle
  \end{itemize}
\item La seule difficulté est de passer d'un algorithme récursif à un algorithme récursif terminal
\end{itemize}

\bigskip

\question{Réécrivez les algorithmes récursifs en récursifs terminaux. Attention, certains sont beaucoup plus complexes que d'autres. (N'essayez pas de convertir l'algorithme d'Ackermann en récursif terminal tant que vous débutez)}


\vfillFirst

\vfillLast


\begin{center}
\textit{Ce document et ses illustrations ont été réalisés par Fabrice BOISSIER en octobre 2024.\\
La plupart des exercices sont inspirés du cahier d'algo de Nathalie "Junior" BOUQUET et Christophe "Krisboul" BOULLAY.}

\textit{(dernière mise à jour octobre 2024)}
\end{center}

\end{document}
