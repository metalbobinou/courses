\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\newcommand{\NomAuteur}{Fabrice BOISSIER}
\newcommand{\TitreMatiere}{Algorithmique 2}
\newcommand{\NomUniv}{EPITA - Bachelor Cyber Sécurité}
\newcommand{\NiveauUniv}{CYBER1}
\newcommand{\NumGroupe}{CYBER1}
\newcommand{\AnneeUniv}{2023-2024}
\newcommand{\DateExam}{juillet 2024}
\newcommand{\TypeExam}{CORRECTION Rattrapage}
\newcommand{\TitreExam}{\TitreMatiere}
\newcommand{\DureeExam}{2h00}
\newcommand{\MyWaterMark}{\AnneeUniv} % Watermark de protection

% Ajout de mes classes & definitions
\usepackage{MetalExam} % Appelle un .sty

% "Tableau" et pas "Table"
\addto\captionsfrench{\def\tablename{Tableau}}

%%%%%%%%%%%%%%%%%%%%%%%
%Header
%%%%%%%%%%%%%%%%%%%%%%%
\lhead{\TypeExam}							%Gauche Haut
\chead{\NomUniv}							%Centre Haut
\rhead{\NumGroupe}							%Droite Haut
\lfoot{\DateExam}							%Gauche Bas
\cfoot{\thepage{} / \pageref*{LastPage}}	%Centre Bas
\rfoot{\texttt{\TitreMatiere}}				%Droite Bas

%%%%%

\usepackage{tabularx}

\newlength{\LabelWidth}%
%\setlength{\LabelWidth}{1.3in}%
\setlength{\LabelWidth}{1cm}%
%\settowidth{\LabelWidth}{Employee E-mail:}%  Specify the widest text here.

% Optional first parameter here specifies the alignment of
% the text within the \makebox.  Default is [l] for left
% alignment. Other options are [r] and [c] for right and center
\newcommand*{\AdjustSize}[2][l]{\makebox[\LabelWidth][#1]{#2}}%


\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C
}


\hyphenation{op-tical net-works SIGKILL}


\begin{document}

%\MakeExamTitleDuree     % Pour afficher la duree
\MakeExamTitle                   % Ne pas afficher la duree

%% \MakeStudentName    %% A reutiliser sur chaque nouvelle page

\bigskip
%\bigskip

Vous devez respecter les consignes suivantes, sous peine de 0 :

\begin{enumerate}[label=\Roman*)]
\item Lisez le sujet en entier une première fois avant de commencer à répondre
\item Lisez le sujet en entier avec attention
\item Ne détachez pas les agrafes du sujet
\item Répondez sur le sujet (et utilisez le brouillon avant de répondre)
\item \'Ecrivez lisiblement vos réponses (si nécessaire en majuscules)
%\item Vous devez écrire dans le langage algorithmique classique ou en C (donc pas de Python ou autre)
\item Ne trichez pas
\end{enumerate}

%\bigskip

\vfillFirst

% Questions cours
\section{Arbres Binaires (14 points)}

\subsection{(4 points) Indiquez toutes les propriétés que possède cet arbre, écrivez les clés lors d'un parcours profondeur main gauche de l'arbre dans les 3 ordres ainsi que lors d'un parcours largeur, puis corrigez-le pour qu'il devienne un arbre binaire strict : }

\begin{center}
\begin{tikzpicture}[sibling distance=1.5cm,
  level/.style = {sibling distance = 55mm/#1},
  level 1/.style = {sibling distance = 55mm},
  level 2/.style = {sibling distance = 30mm},
  level 3/.style = {sibling distance = 15mm},
  level 4/.style = {sibling distance = 10mm},
  every node/.style = {minimum width = 2em, draw, circle},
  ]
  \node (nO1) {O}
  child { node (nA2) {A}
          child { node (nE3) {E}
                  child { node (nL4) {L} }
                  child { node (nB5) {B} }
                }
          child { node (nE6) {E}
                  child { node (nC7) {C}
                          child { node [dashed] (nX) {X} edge from parent [dashed] }
                          child { node (nH8) {H} }
                        }
                  child { node (nL9) {L} }
                }
         }
   child { node (nU10) {U}
           child { node (nP11) {P}
                   child { node (nR12) {R} }
                   child { node (nO13) {O} }
                 }
           child { node (nR14) {R}
                   child { node (nT15) {T} }
                   child { node (nE16) {E} }
                 }
        };
\end{tikzpicture}
%  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
\end{center}

\begin{tabular}{C{3cm} C{3cm} C{3cm} C{3cm}}
Arité : 2 & Taille : 16 & Hauteur : 4 & Nb feuilles : 8 \\
\end{tabular}

%\medskip
%
%\begin{table}[ht!]
%  \centering
%  \begin{minipage}{0.50\textwidth}
%    \centering
%
%\begin{itemize}
%  \item[\CaseCoche] Arbre binaire strict / localement complet \phantom{()}
%  \item[\CaseCoche] Arbre binaire parfait \phantom{()}
%  \item[\CaseCoche] Peigne gauche \phantom{()}
%\end{itemize}
%
%  \end{minipage}
%  \hfillx
%  \begin{minipage}{0.50\textwidth}
%    \centering
%
%\begin{itemize}
%  \item[\checkmark] Arbre binaire (presque) complet \phantom{()}
%  \item[\CaseCoche] Arbre filiforme \phantom{()}
%  \item[\CaseCoche] Peigne droit \phantom{()}
%\end{itemize}
%
%  \end{minipage}
%\end{table}

\bigskip

Parcours profondeur :

\medskip

\centerline{
\begin{tabular}{L{2.5cm} C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm} C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm} C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm} C{0.5cm}C{0.5cm}C{0.5cm}}
ordre préfixe : & O & A & E & L & B & E & C & H & L & U & P & R & O & R & T & E \\
ordre infixe :  & L & E & B & A & C & H & E & L & O & R & P & O & U & T & R & E \\
ordre suffixe : & L & B & E & H & C & L & E & A & R & O & P & T & E & R & U & O \\
\end{tabular}
}

\bigskip

Parcours largeur :

\medskip

\centerline{
\begin{tabular}{L{2.5cm} C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm} C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm} C{0.5cm}C{0.5cm}C{0.5cm}C{0.5cm} C{0.5cm}C{0.5cm}C{0.5cm}}
ordre : & O & A & U & E & E & P & R & L & B & C & L & R & O & T & E & H \\
\end{tabular}
}


\bigskip
\bigskip

\noindent Ajoutez suffisament de nœud(s) sur le schéma pour que l'arbre binaire devienne un \textit{arbre binaire strict}.
Si l'arbre est déjà un arbre binaire strict, laissez-le tel quel sans ajouter de nœud.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vfillLast

\clearpage

%\vfillFirst

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{(4 points) Dessinez le résultat de l'insertion dans cet ordre précis des éléments suivants dans un ABR (insertion en feuille) et dans un AVL : }

\begin{center}

%\'Eléments insérés : 18 - 46 - 55 - 36 - 12 - 38 - 96 - 71
%\'Eléments insérés : 46 - 18 - 55 - 36 - 12 - 38 - 96 - 71
%\'Eléments insérés : 32 - 8 - 16 - 96 - 64 - 72 - 24 - 4
\'Eléments insérés : 42 - 7 - 12 - 83 - 56 - 64 - 21 - 4

\begin{table}[ht!]
  \centering
  \begin{minipage}{0.50\textwidth}
    \centering

\begin{tikzpicture}[
  level/.style = {sibling distance = 26mm/#1},
  every node/.style = {minimum width = 2em, draw, circle}
  ]
  \node (n42) {42}
  child { node (n7) {7}
          child { node (n4) {4}
                  child { node [draw=none] (nA) {\phantom{A}} edge from parent [draw=none] }
                }
          child { node (n12) {12}
                  child { node [draw=none] (nB) {\phantom{B}} edge from parent [draw=none] }
                  child { node (n21) {21} }
                }
        }
  child { node (n83) {83}
          child { node (n56) {56}
                  child { node [draw=none] (nD) {\phantom{D}} edge from parent [draw=none] }
                  child { node (n64) {64} }
                }
          child { node [draw=none] (nC) {\phantom{C}} edge from parent [draw=none] }
        };
\end{tikzpicture}


ABR

\textit{insertion en feuille}

(2 points)
  \end{minipage}
  \hfillx
  \begin{minipage}{0.50\textwidth}
    \centering

\begin{tikzpicture}[
  level/.style = {sibling distance = 26mm/#1},
  every node/.style = {minimum width = 2em, draw, circle}
  ]
  \node (n56) {56}
  child { node (n12) {12}
          child { node (n7) {7}
                  child { node (n4) {4} }
                  child { node [draw=none] (nD) {\phantom{D}} edge from parent [draw=none] }
                }
          child { node (n42) {42}
                  child { node (n21) {21} }
                  child { node [draw=none] (nC) {\phantom{C}} edge from parent [draw=none] }
                }
        }
  child { node (n83) {83}
          child { node (n64) {64} }
          child { node [draw=none] (nC) {\phantom{C}} edge from parent [draw=none] }
        };
\end{tikzpicture}

AVL

(2 points)
  \end{minipage}
%\stepcounter{figure}
%\caption{Fig.\thefigure : Recherche de la clé 24 dans un ABR}
%\label{fig:example2-BST-succeed-search}
\end{table}

\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{(2 points) \'Ecrivez une fonction récursive \og \textit{parc\_prof\_rec} \fg{} effectuant un parcours profondeur main gauche dans un arbre binaire, et affichant les nœuds dans chacun des ordres : }

%\noindent Pour expliciter les ordres, vous devrez afficher au format : \og Ordre : nœud \fg{} (exemple : \og Préfixe : node \fg{})
\noindent Il faut expliciter les éventuels ordres au format : \og Ordre : nœud \fg{} (exemple : \og Préfixe : 42 \fg{})

\vfillFirst

\begin{lstlisting}[language=C]
void parc_prof_rec(node *root)
{
  if (root != NULL)
  {
    printf("Prefixe : %d\n", root->val);

    parc_prof_rec(root->left_child);

    printf("Infixe : %d\n", root->val);

    parc_prof_rec(root->right_child);

    printf("Postfixe : %d\n", root->val);
  }
}
\end{lstlisting}

\vfillLast

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{(2 points) \'Ecrivez une fonction itérative \og \textit{parc\_larg} \fg{} effectuant un parcours largeur dans un arbre binaire, et affichant chacun des nœuds dans l'ordre hiérarchique : }

%\noindent Il faut expliciter les éventuels ordres au format : \og Ordre : nœud \fg{} (exemple : \og Préfixe : 42 \fg{})

%\medskip

\noindent \textit{Vous pouvez utiliser les structures externes suivantes sans les réécrire :}

\noindent \textit{stack\_t (create, push, head, pop, delete) \hfill queue\_t (create, enqueue, head, dequeue, delete) }

\bigskip

\begin{lstlisting}[language=C]
void parc_larg(node *root)
{
  queue_t *q = create_queue();

  if (root != NULL)
    q = enqueue(root);

  while (head(q) != NULL)
  {
    root = head(q);
    q = dequeue(q);

    printf("Hierachique : %d\n", root->val);

    if (root->lc != NULL)
      q = enqueue(root->lc);
    if (root->rc != NULL)
      q = enqueue(root->rc);
  }
}
\end{lstlisting}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{(1 point) \'Ecrivez une fonction récursive \og \textit{hauteur\_arbre} \fg{} calculant la hauteur d'un arbre : }

\begin{lstlisting}[language=C]
int max(int val1, int val2)
{
  if (val1 > val2)
    return (val1);
  else
    return (val2);
}

int hauteur_arbre(node *root)
{
  if (root == NULL)
    return (-1);

  return (1 + max(hauteur_arbre(root->lc), hauteur_arbre(root->rc)));
}
\end{lstlisting}

\medskip

\subsection{(1 point) \'Ecrivez une fonction \og \textit{recherche\_abr} \fg{} recherchant un nœud dans un ABR et le renvoyant. Si le nœud n'est pas trouvé, il faut renvoyer \TTBF{NULL} : }

\begin{lstlisting}[language=C]
node *recherche_abr(node *root, int id_target)
{
  node *tmp = NULL;

  if (root == NULL)
    return (NULL);

  if (root->val == id_target)
    return (root);

  tmp = recherche_abr(root->lc);
  if (tmp != NULL)
    return (tmp);
  else
    return (recherche_abr(root->rc));
}
\end{lstlisting}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Arbres Binaires : Usages (6 points)}


%\noindent Afin de tester l'ensemble des compétences acquises au cours de cette année, vous allez maintenant toutes les exploiter pour interpréter des données et des structures.
%Le but de ces exercices est de vous faire changer de point de vue : vous avez construit des structures durant l'année, vous allez maintenant analyser des structures existantes.

\noindent En mathématiques, vous avez appris tout au long de vos études primaires et secondaires à utiliser plusieurs opérateurs communs : \og $ + - \times \div $ \fg{}.
Ces opérateurs sont tous des opérateurs \textit{binaires}, c'est-à-dire qu'ils prennent deux paramètres : \og $ 3 + 5 $ \fg{} peut également s'écrire \textit{addition(3, 5)}.

\noindent \og $ + $ \fg{} et \og $ - $ \fg{} sont également des opérateurs \textit{unaires} lorsqu'ils représentent le signe de la valeur absolue qui suit : \og $ - 8 $ \fg{} peut aussi s'écrire \textit{négatif(8)}.

\medskip

\noindent Dans cet exercice, vous allez transformer des arbres en formules mathématiques, puis l'inverse, et enfin, écrire l'algorithme de parcours et d'exécution de ces opérations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{(2 points) Transformez les arbres suivants en leurs formules mathématiques associées : }

\begin{table}[ht!]
  \centering
  \begin{minipage}{0.30\textwidth}
    \centering

\begin{center}
\begin{tikzpicture}[sibling distance=1.5cm,
  level/.style = {sibling distance = 26mm/#1},
  every node/.style = {minimum width = 2em, draw, circle}
  ]
  \node (nO1) {$\times$}
  child { node (nV1) {3} }
  child { node (nV2) {5} };
\end{tikzpicture}
%  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
\end{center}

  \end{minipage}
  \hfillx
  \begin{minipage}{0.30\textwidth}
    \centering

\begin{center}
\begin{tikzpicture}[sibling distance=1.5cm,
  level/.style = {sibling distance = 26mm/#1},
  every node/.style = {minimum width = 2em, draw, circle}
  ]
  \node (nO1) {$\div$}
  child { node (nV1) {8} }
  child {
          node (nO2) {$-$}
          child { node (nV2) {4} }
          child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
        };
\end{tikzpicture}
%  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
\end{center}

  \end{minipage}
  \hfillx
  \begin{minipage}{0.40\textwidth}
    \centering

\begin{center}
\begin{tikzpicture}[sibling distance=1.5cm,
  level/.style = {sibling distance = 40mm/#1},
  level 1/.style = {sibling distance = 40mm},
  level 2/.style = {sibling distance = 20mm},
  level 3/.style = {sibling distance = 15mm},
  every node/.style = {minimum width = 2em, draw, circle},
  ]
  \node (nO1) {+}
  child { node (nO2) {$\times$}
          child { node (nV1) {4} }
          child { node (nV2) {2} }
         }
   child { node (nO3) {$-$}
           child { node (nV3) {6} }
           child { node (nV4) {8} }
        };
\end{tikzpicture}
%  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
\end{center}

  \end{minipage}
\end{table}


\begin{table}[ht!]
  \centering
  \begin{minipage}{0.30\textwidth}
    \centering

\textit{(0,5 pt)} Formule :

\medskip

$ 3 \times 5 $

  \end{minipage}
  \hfillx
  \begin{minipage}{0.30\textwidth}
    \centering

\textit{(0,5 pt)} Formule :

\medskip

$ 8 \div (-4) $

  \end{minipage}
  \hfillx
  \begin{minipage}{0.40\textwidth}
    \centering

\textit{(0.5 pt)} Formule :

\medskip

$ (4 \times 2) + (6 - 8) $

  \end{minipage}
\end{table}

%\vspace*{1cm}

\noindent \textit{(0.5 point)} Que remarquez-vous concernant les opérateurs et les nombres par rapport à leur placement dans les arbres ?

\medskip

Les nœuds internes de l'arbre ne contiennent que des opérateurs, et les feuilles/nœuds externes ne contiennent que des nombres.

%\bigskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{(2 points) Transformez chacune des formules suivantes en un arbre binaire : }

\vspace*{-0.5cm}

\begin{table}[ht!]
  \centering
  \begin{minipage}{0.25\textwidth}
    \centering

\textit{(0,5 point)}

$ 3 \times (4 - 5) $

  \end{minipage}
  \hfillx
  \begin{minipage}{0.25\textwidth}
    \centering

\textit{(0,5 point)}

$ (-5) \div (8 + 3) $

  \end{minipage}
  \hfillx
  \begin{minipage}{0.50\textwidth}
    \centering

\textit{(1 point)}

$ (6 \times (-4)) + ((-8) \div (5 - 3)) $

  \end{minipage}
\end{table}

\begin{table}[ht!]
  \centering
  \begin{minipage}{0.25\textwidth}
    \centering

\begin{center}
\begin{tikzpicture}[sibling distance=1.5cm,
  level/.style = {sibling distance = 26mm/#1},
  every node/.style = {minimum width = 2em, draw, circle}
  ]
  \node (nO1) {$\times$}
  child { node (nV1) {3} }
  child {
          node (nO2) {$-$}
          child { node (nV2) {4} }
          child { node (nV3) {5} }
        };
\end{tikzpicture}
%  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
\end{center}

  \end{minipage}
  \hfillx
  \begin{minipage}{0.25\textwidth}
    \centering

\begin{center}
\begin{tikzpicture}[sibling distance=1.5cm,
  level/.style = {sibling distance = 26mm/#1},
  every node/.style = {minimum width = 2em, draw, circle}
  ]
  \node (nO1) {$\div$}
  child {
          node (nO2) {$-$}
          child { node (nV1) {5} }
        }
  child {
          node (nO2) {$+$}
          child { node (nV2) {8} }
          child { node (nV3) {3} }
        };
\end{tikzpicture}
%  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
\end{center}

  \end{minipage}
  \hfillx
  \begin{minipage}{0.50\textwidth}
    \centering

\begin{center}
\begin{tikzpicture}[sibling distance=1.5cm,
  level/.style = {sibling distance = 40mm/#1},
  level 1/.style = {sibling distance = 40mm},
  level 2/.style = {sibling distance = 20mm},
  level 3/.style = {sibling distance = 15mm},
  every node/.style = {minimum width = 2em, draw, circle},
  ]
  \node (nO1) {+}
  child { node (nO2) {$\times$}
          child { node (nV1) {6} }
          child {
                  node (nO3) {$-$}
                  child { node (nV2) {4} }
                  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
                }
         }
   child { node (nO4) {$\div$}
           child {
                   node (nO5) {$-$}
                   child { node (nV3) {8} }
                   child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
                 }
           child {
                   node (nO6) {$-$}
                   child { node (nV4) {5} }
                   child { node (nV5) {3} }
                 }
        };
\end{tikzpicture}
%  child { node [draw=none] (nX) {\phantom{X}} edge from parent [draw=none] }
\end{center}

  \end{minipage}
\end{table}

\vspace*{3cm}

%\bigskip

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{(2 points) \'Ecrivez une fonction \og \textit{exec\_maths\_tree} \fg{} exécutant l'expression représentée par l'arbre binaire donné en paramètre, et renvoyant le résultat : }

\noindent Chaque nœud de cet arbre est une structure contenant du texte en tant que valeur, vous pouvez utiliser les fonctions suivantes pour tester ou extraire le contenu de la valeur.
Les nœuds ne contiendront jamais autre chose que l'un des 4 opérateurs ou un nombre, et l'arbre ne sera jamais vide.

\vspace*{-0.5cm}

\begin{center}

\begin{table}[ht!]
  \centering
  \begin{minipage}{0.38\textwidth}
    \centering

\begin{lstlisting}[language=C]
typedef struct math_node
{
  char *value;
  struct math_node lc;
  struct math_node rc;
} math_node; \end{lstlisting}

  \end{minipage}
  \hfillx
  \begin{minipage}{0.57\textwidth}

\noindent \TTBF{int UnaryOp(char *op, int val)} : fonction exécutant l'opérateur fournit en paramètre sur la valeur.

\smallskip

\noindent \TTBF{int BinaryOp(char *op, int v1, int v2)} : fonction exécutant l'opérateur fournit en paramètre sur les 2 valeurs.

\smallskip

\noindent \TTBF{int atoi(char *text)} : fonction transformant le texte donné en paramètre en un entier.

  \end{minipage}
\end{table}

\end{center}

\begin{lstlisting}[language=C]
int exec_rec(math_node *root)
{
  // Si feuille, alors c'est un nombre a retourner tel quel
  if ((root->lc == NULL) && (root->rc == NULL))
    return (atoi(root->val));

  // Si noeud ne contient qu'un fils, c'est un operateur unaire
  if ((root->lc == NULL) && (root->rc != NULL) ||
      (root->lc != NULL) && (root->rc == NULL))
    // [detection du fils non nul]
    if (root->lc != NULL)
      return (UnaryOp(root->val, exec_rec(root->lc)));
    else
      return (UnaryOp(root->val, exec_rec(root->rc)));

  // Dans tous les autres cas, c'est un operateur binaire
  return (BinaryOp(root->val,
                   exec_rec(root->lc),
                   exec_rec(root->rc)));
}


int exec_maths_tree(math_node *root)
{
  /* Arbre jamais vide : pas de if de test */

  return (exec_rec(root));
}



\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\clearpage
%
%
%%\thispagestyle{empty}
%
%\vfillFirst
%
%\begin{center}
%
%\begin{LARGE}
%\textbf{RATTRAPAGE ALGORITHMIQUE 2}
%\end{LARGE}
%
%\end{center}
%
%\vfillLast

\end{document}
